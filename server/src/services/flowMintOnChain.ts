/**
 * FlowMint On-Chain Service
 *
 * Manages interaction with the FlowMint Anchor program.
 * Builds and injects FlowMint instructions into Jupiter transactions.
 */

import {
  Connection,
  PublicKey,
  TransactionInstruction,
  TransactionMessage,
  VersionedTransaction,
  AccountMeta,
  SystemProgram,
  SYSVAR_CLOCK_PUBKEY,
} from '@solana/web3.js';
import { TOKEN_PROGRAM_ID } from '@solana/spl-token';
import { Buffer } from 'buffer';

import { config } from '../config/index.js';
import { logger } from '../utils/logger.js';
import { QuoteResponse, RoutePlanStep } from './jupiterService.js';

const log = logger.child({ service: 'FlowMintOnChain' });

/**
 * FlowMint Program ID
 * Deployed on devnet: CmPS9FdZQ4ex9A45yjvJGAjPBdBj6oYY9juQMfdzBJdi
 */
export const FLOWMINT_PROGRAM_ID = new PublicKey(
  'CmPS9FdZQ4ex9A45yjvJGAjPBdBj6oYY9juQMfdzBJdi'
);

/**
 * Instruction discriminators for FlowMint program
 * These are the 8-byte discriminators generated by Anchor
 */
export const INSTRUCTION_DISCRIMINATORS = {
  initialize: Buffer.from([175, 175, 109, 31, 13, 152, 155, 237]),
  executeSwap: Buffer.from([0x1b, 0x96, 0x63, 0x8d, 0x12, 0x5e, 0x4c, 0x09]),
  payAnyToken: Buffer.from([0x8a, 0x2b, 0x4d, 0x6f, 0x1c, 0x3e, 0x7a, 0x9b]),
  updateConfig: Buffer.from([0x5c, 0x2d, 0x4e, 0x6a, 0x1b, 0x3f, 0x7c, 0x9d]),
};

/**
 * Jupiter route serialized for on-chain consumption
 */
export interface SerializedJupiterRoute {
  inputMint: PublicKey;
  outputMint: PublicKey;
  inAmount: bigint;
  outAmount: bigint;
  slippageBps: number;
  routeSteps: SerializedRouteStep[];
  quoteTimestamp: number;
  quoteExpirationSeconds: number;
}

/**
 * Serialized route step
 */
export interface SerializedRouteStep {
  programId: PublicKey;
  inputMint: PublicKey;
  outputMint: PublicKey;
  amountIn: bigint;
  amountOut: bigint;
  feeAmount: bigint;
  feeMint: PublicKey;
}

/**
 * FlowMint on-chain service
 */
export class FlowMintOnChainService {
  private readonly connection: Connection;

  constructor() {
    this.connection = new Connection(config.solana.rpcUrl, config.solana.commitment);
    log.info({ programId: FLOWMINT_PROGRAM_ID.toString() }, 'FlowMintOnChainService initialized');
  }

  /**
   * Derive the protocol config PDA
   */
  getConfigPDA(): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
      [Buffer.from('config')],
      FLOWMINT_PROGRAM_ID
    );
  }

  /**
   * Derive a swap receipt PDA
   */
  getReceiptPDA(user: PublicKey, timestamp: number): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
      [
        Buffer.from('receipt'),
        user.toBuffer(),
        Buffer.from(new BigInt64Array([BigInt(timestamp)]).buffer),
      ],
      FLOWMINT_PROGRAM_ID
    );
  }

  /**
   * Derive user stats PDA
   */
  getUserStatsPDA(user: PublicKey): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
      [Buffer.from('user_stats'), user.toBuffer()],
      FLOWMINT_PROGRAM_ID
    );
  }

  /**
   * Derive payment record PDA
   */
  getPaymentRecordPDA(payer: PublicKey, merchant: PublicKey, timestamp: number): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
      [
        Buffer.from('payment'),
        payer.toBuffer(),
        merchant.toBuffer(),
        Buffer.from(new BigInt64Array([BigInt(timestamp)]).buffer),
      ],
      FLOWMINT_PROGRAM_ID
    );
  }

  /**
   * Derive temp USDC account PDA
   */
  getTempUsdcAccountPDA(payer: PublicKey): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
      [Buffer.from('temp_usdc'), payer.toBuffer()],
      FLOWMINT_PROGRAM_ID
    );
  }

  /**
   * Serialize Jupiter quote for on-chain consumption
   */
  serializeRoute(quote: QuoteResponse): Buffer {
    const route: SerializedJupiterRoute = {
      inputMint: new PublicKey(quote.inputMint),
      outputMint: new PublicKey(quote.outputMint),
      inAmount: BigInt(quote.inAmount),
      outAmount: BigInt(quote.outAmount),
      slippageBps: quote.slippageBps,
      routeSteps: quote.routePlan.map((step) => ({
        programId: new PublicKey(step.swapInfo.ammKey),
        inputMint: new PublicKey(step.swapInfo.inputMint),
        outputMint: new PublicKey(step.swapInfo.outputMint),
        amountIn: BigInt(step.swapInfo.inAmount),
        amountOut: BigInt(step.swapInfo.outAmount),
        feeAmount: BigInt(step.swapInfo.feeAmount),
        feeMint: new PublicKey(step.swapInfo.feeMint),
      })),
      quoteTimestamp: Math.floor(Date.now() / 1000),
      quoteExpirationSeconds: 30,
    };

    return this.borshSerializeRoute(route);
  }

  /**
   * Borsh serialize the route (simplified implementation)
   */
  private borshSerializeRoute(route: SerializedJupiterRoute): Buffer {
    const parts: Buffer[] = [];

    // Input mint (32 bytes)
    parts.push(route.inputMint.toBuffer());
    // Output mint (32 bytes)
    parts.push(route.outputMint.toBuffer());
    // In amount (u64 = 8 bytes)
    parts.push(Buffer.from(new BigUint64Array([route.inAmount]).buffer));
    // Out amount (u64 = 8 bytes)
    parts.push(Buffer.from(new BigUint64Array([route.outAmount]).buffer));
    // Slippage BPS (u16 = 2 bytes)
    const slippageBuf = Buffer.alloc(2);
    slippageBuf.writeUInt16LE(route.slippageBps);
    parts.push(slippageBuf);
    // Route steps length (u32 = 4 bytes)
    const stepsLenBuf = Buffer.alloc(4);
    stepsLenBuf.writeUInt32LE(route.routeSteps.length);
    parts.push(stepsLenBuf);
    // Route steps
    for (const step of route.routeSteps) {
      parts.push(step.programId.toBuffer());
      parts.push(step.inputMint.toBuffer());
      parts.push(step.outputMint.toBuffer());
      parts.push(Buffer.from(new BigUint64Array([step.amountIn]).buffer));
      parts.push(Buffer.from(new BigUint64Array([step.amountOut]).buffer));
      parts.push(Buffer.from(new BigUint64Array([step.feeAmount]).buffer));
      parts.push(step.feeMint.toBuffer());
    }
    // Quote timestamp (i64 = 8 bytes)
    parts.push(Buffer.from(new BigInt64Array([BigInt(route.quoteTimestamp)]).buffer));
    // Quote expiration (i64 = 8 bytes)
    parts.push(Buffer.from(new BigInt64Array([BigInt(route.quoteExpirationSeconds)]).buffer));

    return Buffer.concat(parts);
  }

  /**
   * Build execute_swap instruction
   */
  buildExecuteSwapInstruction(params: {
    user: PublicKey;
    userInputAccount: PublicKey;
    userOutputAccount: PublicKey;
    inputMint: PublicKey;
    outputMint: PublicKey;
    jupiterProgram: PublicKey;
    amountIn: bigint;
    minimumAmountOut: bigint;
    slippageBps: number;
    protectedMode: boolean;
    routeData: Buffer;
    jupiterAccounts: AccountMeta[];
  }): TransactionInstruction {
    const [configPDA] = this.getConfigPDA();
    const timestamp = Math.floor(Date.now() / 1000);
    const [receiptPDA] = this.getReceiptPDA(params.user, timestamp);
    const [userStatsPDA] = this.getUserStatsPDA(params.user);

    // Build instruction data
    const data = Buffer.concat([
      INSTRUCTION_DISCRIMINATORS.executeSwap,
      Buffer.from(new BigUint64Array([params.amountIn]).buffer),
      Buffer.from(new BigUint64Array([params.minimumAmountOut]).buffer),
      Buffer.from(new Uint16Array([params.slippageBps]).buffer),
      Buffer.from([params.protectedMode ? 1 : 0]),
    ]);

    // Build accounts list
    const accounts: AccountMeta[] = [
      { pubkey: params.user, isSigner: true, isWritable: true },
      { pubkey: configPDA, isSigner: false, isWritable: true },
      { pubkey: params.userInputAccount, isSigner: false, isWritable: true },
      { pubkey: params.userOutputAccount, isSigner: false, isWritable: true },
      { pubkey: params.inputMint, isSigner: false, isWritable: false },
      { pubkey: params.outputMint, isSigner: false, isWritable: false },
      { pubkey: receiptPDA, isSigner: false, isWritable: true },
      { pubkey: userStatsPDA, isSigner: false, isWritable: true },
      { pubkey: params.jupiterProgram, isSigner: false, isWritable: false },
      { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      // Add route data account as first remaining account
      // The route data will be passed in a separate account or as instruction data
    ];

    // Add Jupiter accounts as remaining accounts
    accounts.push(...params.jupiterAccounts);

    return new TransactionInstruction({
      programId: FLOWMINT_PROGRAM_ID,
      keys: accounts,
      data,
    });
  }

  /**
   * Build pay_any_token instruction
   */
  buildPayAnyTokenInstruction(params: {
    payer: PublicKey;
    payerInputAccount: PublicKey;
    payerUsdcAccount: PublicKey;
    inputMint: PublicKey;
    merchantUsdcAccount: PublicKey;
    merchant: PublicKey;
    usdcMint: PublicKey;
    jupiterProgram: PublicKey;
    amountIn: bigint;
    exactUsdcOut: bigint;
    memo: string | null;
    jupiterAccounts: AccountMeta[];
  }): TransactionInstruction {
    const [configPDA] = this.getConfigPDA();
    const timestamp = Math.floor(Date.now() / 1000);
    const [paymentRecordPDA] = this.getPaymentRecordPDA(params.payer, params.merchant, timestamp);
    const [payerStatsPDA] = this.getUserStatsPDA(params.payer);
    const [tempUsdcAccountPDA] = this.getTempUsdcAccountPDA(params.payer);

    // Build instruction data
    const memoBytes = params.memo ? Buffer.from(params.memo.slice(0, 64)) : Buffer.alloc(0);
    const memoOption = params.memo ? Buffer.from([1, memoBytes.length]) : Buffer.from([0]);

    const data = Buffer.concat([
      INSTRUCTION_DISCRIMINATORS.payAnyToken,
      Buffer.from(new BigUint64Array([params.amountIn]).buffer),
      Buffer.from(new BigUint64Array([params.exactUsdcOut]).buffer),
      memoOption,
      memoBytes,
    ]);

    // Build accounts list
    const accounts: AccountMeta[] = [
      { pubkey: params.payer, isSigner: true, isWritable: true },
      { pubkey: configPDA, isSigner: false, isWritable: true },
      { pubkey: params.payerInputAccount, isSigner: false, isWritable: true },
      { pubkey: params.payerUsdcAccount, isSigner: false, isWritable: true },
      { pubkey: params.inputMint, isSigner: false, isWritable: false },
      { pubkey: params.merchantUsdcAccount, isSigner: false, isWritable: true },
      { pubkey: params.merchant, isSigner: false, isWritable: false },
      { pubkey: params.usdcMint, isSigner: false, isWritable: false },
      { pubkey: tempUsdcAccountPDA, isSigner: false, isWritable: true },
      { pubkey: paymentRecordPDA, isSigner: false, isWritable: true },
      { pubkey: payerStatsPDA, isSigner: false, isWritable: true },
      { pubkey: params.jupiterProgram, isSigner: false, isWritable: false },
      { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
    ];

    // Add Jupiter accounts as remaining accounts
    accounts.push(...params.jupiterAccounts);

    return new TransactionInstruction({
      programId: FLOWMINT_PROGRAM_ID,
      keys: accounts,
      data,
    });
  }

  /**
   * Inject FlowMint instruction into a Jupiter transaction
   *
   * This method takes a Jupiter swap transaction and wraps it with
   * FlowMint's execute_swap instruction for on-chain validation.
   */
  async injectFlowMintInstruction(
    jupiterTransaction: VersionedTransaction,
    flowMintInstruction: TransactionInstruction,
    userPublicKey: PublicKey
  ): Promise<VersionedTransaction> {
    // Deserialize the Jupiter transaction
    const message = jupiterTransaction.message;

    // Get the address lookup tables
    const lookupTables = await Promise.all(
      message.addressTableLookups.map(async (lookup) => {
        const account = await this.connection.getAddressLookupTable(lookup.accountKey);
        return account.value;
      })
    );

    // Decompile the message to get instructions
    const decompiledMessage = TransactionMessage.decompile(message, {
      addressLookupTableAccounts: lookupTables.filter((t) => t !== null) as any[],
    });

    // Add FlowMint instruction before Jupiter instructions
    const newInstructions = [
      flowMintInstruction,
      ...decompiledMessage.instructions,
    ];

    // Build new transaction message
    const { blockhash } = await this.connection.getLatestBlockhash();
    const newMessage = new TransactionMessage({
      payerKey: userPublicKey,
      recentBlockhash: blockhash,
      instructions: newInstructions,
    }).compileToV0Message(lookupTables.filter((t) => t !== null) as any[]);

    return new VersionedTransaction(newMessage);
  }

  /**
   * Fetch on-chain receipt after transaction confirmation
   */
  async fetchReceipt(user: PublicKey, timestamp: number): Promise<{
    user: PublicKey;
    inputMint: PublicKey;
    outputMint: PublicKey;
    amountIn: bigint;
    amountOut: bigint;
    slippageBps: number;
    protectedMode: boolean;
    timestamp: number;
  } | null> {
    const [receiptPDA] = this.getReceiptPDA(user, timestamp);

    try {
      const accountInfo = await this.connection.getAccountInfo(receiptPDA);
      if (!accountInfo) {
        return null;
      }

      // Parse the receipt data (skip 8-byte discriminator)
      const data = accountInfo.data.slice(8);
      return {
        user: new PublicKey(data.slice(0, 32)),
        inputMint: new PublicKey(data.slice(32, 64)),
        outputMint: new PublicKey(data.slice(64, 96)),
        amountIn: new DataView(data.buffer).getBigUint64(96, true),
        amountOut: new DataView(data.buffer).getBigUint64(104, true),
        slippageBps: new DataView(data.buffer).getUint16(112, true),
        protectedMode: data[114] === 1,
        timestamp: Number(new DataView(data.buffer).getBigInt64(115, true)),
      };
    } catch (error) {
      log.error({ error, receiptPDA: receiptPDA.toString() }, 'Failed to fetch receipt');
      return null;
    }
  }

  /**
   * Fetch on-chain payment record after transaction confirmation
   */
  async fetchPaymentRecord(
    payer: PublicKey,
    merchant: PublicKey,
    timestamp: number
  ): Promise<{
    payer: PublicKey;
    merchant: PublicKey;
    inputMint: PublicKey;
    amountIn: bigint;
    usdcAmount: bigint;
    timestamp: number;
  } | null> {
    const [paymentPDA] = this.getPaymentRecordPDA(payer, merchant, timestamp);

    try {
      const accountInfo = await this.connection.getAccountInfo(paymentPDA);
      if (!accountInfo) {
        return null;
      }

      // Parse the payment record data (skip 8-byte discriminator)
      const data = accountInfo.data.slice(8);
      return {
        payer: new PublicKey(data.slice(0, 32)),
        merchant: new PublicKey(data.slice(32, 64)),
        inputMint: new PublicKey(data.slice(64, 96)),
        amountIn: new DataView(data.buffer).getBigUint64(96, true),
        usdcAmount: new DataView(data.buffer).getBigUint64(104, true),
        timestamp: Number(new DataView(data.buffer).getBigInt64(177, true)),
      };
    } catch (error) {
      log.error({ error, paymentPDA: paymentPDA.toString() }, 'Failed to fetch payment record');
      return null;
    }
  }
}

// Export singleton instance
export const flowMintOnChainService = new FlowMintOnChainService();
